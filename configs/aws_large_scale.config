// AWS Batch configuration optimized for large-scale RNA-seq processing (100-2000 samples)

process.executor = 'awsbatch'
process.queue = 'your-aws-batch-queue'  // UPDATE THIS
workDir = 's3://your-bucket/work'       // UPDATE THIS

aws.region = 'us-east-1'                // UPDATE THIS
aws.batch.cliPath = '/home/ec2-user/miniconda/bin/aws'

// Enable Docker
docker.enabled = true
docker.registry = 'quay.io'

// Aggressive parallelization settings
executor {
    queueSize = 1000
    submitRateLimit = '50/1min'
    pollInterval = '30 sec'
}

// Process resource configuration for large-scale analysis
process {
    errorStrategy = { task.exitStatus in [143,137,104,134,139] ? 'retry' : 'finish' }
    maxRetries = 3
    maxErrors = '-1'
    
    // QC and preprocessing (lower resources, high parallelization)
    withName: 'NFCORE_RNASEQ:RNASEQ:FASTQC_UMITOOLS_TRIMGALORE:FASTQC' {
        cpus = 2
        memory = { check_max(4.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
    }
    
    withName: 'NFCORE_RNASEQ:RNASEQ:FASTQC_UMITOOLS_TRIMGALORE:TRIMGALORE' {
        cpus = 4
        memory = { check_max(8.GB * task.attempt, 'memory') }
        time = { check_max(6.h * task.attempt, 'time') }
    }
    
    // STAR alignment (memory-intensive, scale appropriately)
    withName: 'NFCORE_RNASEQ:RNASEQ:ALIGN_STAR:STAR_ALIGN' {
        cpus = { check_max(16 * task.attempt, 'cpus') }
        memory = { check_max(64.GB * task.attempt, 'memory') }
        time = { check_max(12.h * task.attempt, 'time') }
    }
    
    withName: 'NFCORE_RNASEQ:RNASEQ:ALIGN_STAR:STAR_ALIGN_IGENOMES' {
        cpus = { check_max(16 * task.attempt, 'cpus') }
        memory = { check_max(64.GB * task.attempt, 'memory') }
        time = { check_max(12.h * task.attempt, 'time') }
    }
    
    // BAM processing
    withName: 'NFCORE_RNASEQ:RNASEQ:ALIGN_STAR:BAM_SORT_STATS_SAMTOOLS:SAMTOOLS_SORT' {
        cpus = 8
        memory = { check_max(32.GB * task.attempt, 'memory') }
        time = { check_max(8.h * task.attempt, 'time') }
    }
    
    withName: 'NFCORE_RNASEQ:RNASEQ:ALIGN_STAR:BAM_SORT_STATS_SAMTOOLS:SAMTOOLS_INDEX' {
        cpus = 4
        memory = { check_max(8.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
    }
    
    // Salmon quantification
    withName: 'NFCORE_RNASEQ:RNASEQ:QUANTIFY_STAR_SALMON:SALMON_QUANT' {
        cpus = { check_max(8 * task.attempt, 'cpus') }
        memory = { check_max(32.GB * task.attempt, 'memory') }
        time = { check_max(8.h * task.attempt, 'time') }
    }
    
    // featureCounts (if enabled)
    withName: 'NFCORE_RNASEQ:RNASEQ:QUANTIFY_STAR_SALMON:SUBREAD_FEATURECOUNTS' {
        cpus = 4
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(6.h * task.attempt, 'time') }
    }
    
    // MultiQC (single process, needs enough memory for all samples)
    withName: 'NFCORE_RNASEQ:RNASEQ:MULTIQC' {
        cpus = 4
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
    }
}

// Increased resource limits for large-scale processing
params {
    max_cpus = 32
    max_memory = 128.GB
    max_time = 48.h
}

// Function to check maximum resource allocation (must be defined in each config)
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min(obj, params.max_cpus as int)
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}
