// Main Nextflow configuration for nf-core/rnaseq pipeline
// Supports local and AWS execution with Docker containers

// Define configuration profiles
profiles {
    local {
        process.executor = 'local'
        docker.enabled = true
        docker.runOptions = '-u $(id -u):$(id -g)'
        
        // Resource limits for local execution
        process {
            cpus = { check_max(4 * task.attempt, 'cpus') }
            memory = { check_max(8.GB * task.attempt, 'memory') }
            time = { check_max(4.h * task.attempt, 'time') }
            
            errorStrategy = { task.exitStatus in [143,137,104,134,139] ? 'retry' : 'finish' }
            maxRetries = 1
            maxErrors = '-1'
        }
    }
    
    aws {
        process.executor = 'awsbatch'
        process.queue = 'your-aws-batch-queue'  // UPDATE THIS
        workDir = 's3://your-bucket/work'       // UPDATE THIS
        
        aws.region = 'us-east-1'                // UPDATE THIS
        aws.batch.cliPath = '/home/ec2-user/miniconda/bin/aws'
        
        docker.enabled = true
        docker.registry = 'quay.io'
        
        // AWS Batch resource configuration
        process {
            errorStrategy = { task.exitStatus in [143,137,104,134,139] ? 'retry' : 'finish' }
            maxRetries = 2
            maxErrors = '-1'
            
            // Default resources
            cpus = { check_max(4 * task.attempt, 'cpus') }
            memory = { check_max(16.GB * task.attempt, 'memory') }
            time = { check_max(8.h * task.attempt, 'time') }
            
            // Process-specific resources for memory-intensive steps
            withName: 'NFCORE_RNASEQ:RNASEQ:ALIGN_STAR:STAR_ALIGN' {
                cpus = { check_max(12 * task.attempt, 'cpus') }
                memory = { check_max(48.GB * task.attempt, 'memory') }
                time = { check_max(12.h * task.attempt, 'time') }
            }
            
            withName: 'NFCORE_RNASEQ:RNASEQ:ALIGN_STAR:STAR_ALIGN_IGENOMES' {
                cpus = { check_max(12 * task.attempt, 'cpus') }
                memory = { check_max(48.GB * task.attempt, 'memory') }
                time = { check_max(12.h * task.attempt, 'time') }
            }
            
            withName: 'NFCORE_RNASEQ:RNASEQ:QUANTIFY_STAR_SALMON:SALMON_QUANT' {
                cpus = { check_max(8 * task.attempt, 'cpus') }
                memory = { check_max(32.GB * task.attempt, 'memory') }
                time = { check_max(8.h * task.attempt, 'time') }
            }
        }
    }
    
    // Combined profile for AWS with high parallelization
    aws_large_scale {
        includeConfig 'configs/aws_large_scale.config'
    }
}

// Global parameters
params {
    // Pipeline version
    nf_core_pipeline = 'nf-core/rnaseq'
    nf_core_version = '3.14.0'
    
    // Input/output
    input = null  // Path to samplesheet CSV
    outdir = './results'
    
    // Reference genome (use 'GRCh38' or 'GRCm39')
    genome = null
    
    // Alternative: provide custom reference files
    fasta = null
    gtf = null
    star_index = null
    salmon_index = null
    
    // Library strandedness: 'unstranded', 'forward', 'reverse', 'auto'
    strandedness = 'auto'
    
    // Aligner options
    aligner = 'star_salmon'  // 'star_salmon' | 'star_rsem' | 'hisat2'
    pseudo_aligner = null    // Can set to 'salmon' for pseudoalignment only
    
    // Quantification
    skip_alignment = false
    
    // Optional: enable featureCounts in addition to Salmon
    extra_star_align_args = null
    
    // Quality control
    skip_fastqc = false
    skip_multiqc = false
    
    // Trimming
    skip_trimming = false
    trimmer = 'trimgalore'  // 'trimgalore' | 'fastp'
    
    // Performance
    save_trimmed = false
    save_unaligned = false
    save_align_intermeds = false
    save_reference = false
    
    // Resource limits (for check_max function)
    max_cpus = 16
    max_memory = 128.GB
    max_time = 240.h
}

// Function to check maximum resource allocation
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min(obj, params.max_cpus as int)
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}

// Capture exit codes from upstream processes
process.shell = ['/bin/bash', '-euo', 'pipefail']

// Singularity/Apptainer options (if needed later)
singularity {
    enabled = false
    autoMounts = true
}

// Manifest
manifest {
    name = 'nf-core-rnaseq-wrapper'
    author = 'Chris Frank'
    description = 'Wrapper configuration for nf-core/rnaseq pipeline'
    mainScript = 'main.nf'
    nextflowVersion = '>=23.04.0'
    version = '1.0.0'
}

// Report generation
timeline {
    enabled = true
    file = "${params.outdir}/pipeline_info/execution_timeline.html"
}
report {
    enabled = true
    file = "${params.outdir}/pipeline_info/execution_report.html"
}
trace {
    enabled = true
    file = "${params.outdir}/pipeline_info/execution_trace.txt"
}
dag {
    enabled = true
    file = "${params.outdir}/pipeline_info/pipeline_dag.svg"
}
